# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Create a natural cubic spline basis
#'
#' @param X the locations at which the spline functions will be evaluated. The
#' matrix will have \code{length(X)} rows.
#' @param knots the knot locations. The first and last knots are the boundary
#' knots, and the rest are internal knots. The matrix will have
#' \code{length(knots)} knots.
#' @return the basis matrix
#' @details The basis used by this function is described in \emph{The Elements
#' of Statistical Learning} by Hastie and Tibshirani, in the appendix of
#' Chapter 5 (2nd edition).
#' @export
nsbasis <- function(X, knots) {
    .Call('_gpcovr_nsbasis', PACKAGE = 'gpcovr', X, knots)
}

#' Predict values from spline basis
#'
#' Given a natural spline basis and a set of coefficients, returns the
#' values along the fitted curve.
#'
#' @param basis An \code{n} by \code{k} spline basis matrix, where \code{n}
#' is the number of points the curve will be evaluated at and \code{k} is the
#' number of knots. Should be the output of \code{\link{nsbasis}}.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @return A vector of length \code{n} containing the fitted values.
#' @seealso \code{\link{dloglogspline}} for the same thing but shifted so that
#' it integrates to 1 when exponentiated.
#' @export
predict_natspl <- function(basis, coefs) {
    .Call('_gpcovr_predict_natspl', PACKAGE = 'gpcovr', basis, coefs)
}

#' Evaluate the un-normalized log spectral density
#'
#' @param basis An \code{n} by \code{k} spline basis matrix, where \code{n}
#' is the number of points the curve will be evaluated at and \code{k} is the
#' number of knots. Should be the output of \code{\link{nsbasis}}.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of length \code{n} containing the log density.
#' @seealso \code{\link{predict_natspl}} for the log of this function.
#' @export
dlogspline_unnorm <- function(basis, coefs, knots) {
    .Call('_gpcovr_dlogspline_unnorm', PACKAGE = 'gpcovr', basis, coefs, knots)
}

#' Calculate the normalizing constant for the log spectral density
#'
#' The log density given by \code{\link{dlogspline_unnorm}} is not a valid
#' density because it does not generally integrate to 1. This function finds
#' the constant C such that 1/C times \code{dlogspine_unnorm} will integrate
#' to 1.
#'
#' @param basis An \code{n} by \code{k} spline basis matrix, where \code{n}
#' is the number of points the curve will be evaluated at and \code{k} is the
#' number of knots. Should be the output of \code{\link{nsbasis}}.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return the normalizing constant C
#' @seealso \code{\link{dlogspline_unnorm}}, \code{\link{dlogspline}}
#' @export
normalize_dlogspline <- function(basis, coefs, knots) {
    .Call('_gpcovr_normalize_dlogspline', PACKAGE = 'gpcovr', basis, coefs, knots)
}

#' Evaluate the log spectral density
#'
#' @param x The values at which to evaluate the log density.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of log density values.
#' @export
dlogspline <- function(x, coefs, knots) {
    .Call('_gpcovr_dlogspline', PACKAGE = 'gpcovr', x, coefs, knots)
}

#' Evaluate the log of the log spectral density
#'
#' @param x The values at which to evaluate the log of the log density.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of log log density values.
#' @export
dloglogspline <- function(x, coefs, knots) {
    .Call('_gpcovr_dloglogspline', PACKAGE = 'gpcovr', x, coefs, knots)
}

#' Get slopes beyond the knot boundaries
#'
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of length 2 containing the following values:
#' \enumerate{
#'   \item \eqn{f(kmin) - f(kmin - 1)}
#'   \item \eqn{f(kmax + 1) - f(kmax)}
#' }
#' where \code{kmin} and \code{kmax} are the minimum and maximum knots and
#' \code{f} is the unnormalized log log density. The first value is the left
#' tail slope and the second is the right tail slope.
#' @export
get_slopes <- function(coefs, knots) {
    .Call('_gpcovr_get_slopes', PACKAGE = 'gpcovr', coefs, knots)
}

#' Evaluate points beyond the knot boundaries
#'
#' Since we are using a natural spline basis, the fitted curve beyond the
#' boundary knots is guaranteed to be linear. To quickly find the slopes
#' of these linear tails, this function evaluates the fitted curve at four
#' points: the boundary knots, as well as at a point slightly
#' beyond each boundary knot.
#'
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of length 4 containing the following values:
#' \enumerate{
#'   \item \eqn{f(kmin - 1)}
#'   \item \eqn{f(kmin)}
#'   \item \eqn{f(kmax)}
#'   \item \eqn{f(kmax + 1)}
#' }
#' where \code{kmin} and \code{kmax} are the minimum and maximum knots and
#' \code{f} is the log log density. Then the left tail slope is
#' \eqn{f(kmin) - f(kmin - 1)} and the right tail slope is
#' \eqn{f(kmax+ 1) - f(kmax)}.
#' @export
get_slope_pts <- function(coefs, knots) {
    .Call('_gpcovr_get_slope_pts', PACKAGE = 'gpcovr', coefs, knots)
}

#' Evaluate the CDF of the log spectral density
#'
#' This function should probably not be used directly. It relies on there
#' being a (relatively) large number of \code{x} values supplied between the
#' boundary knots. The values of \code{x} are used to create a grid over
#' which the trapezoid rule is applied to determine the CDF values. If very
#' few \code{x} values are given, this function's behavior will be unreliable
#' and probably inaccurate.
#'
#' @param x The values at which to evaluate the CDF.
#' @param coefs A vector of length \code{k} representing the basis coefficients.
#' @param knots A vector of length \code{k} representing the knot locations.
#' @return A vector of CDF values. These are always returned in ascending order.
#' This is another reason you probably don't want to use this function directly.
#' @export
plogspline <- function(x, coefs, knots) {
    .Call('_gpcovr_plogspline', PACKAGE = 'gpcovr', x, coefs, knots)
}

#' Evaluate the inverse CDF of the log spectral density
#'
#' AKA the quantile function.
#'
#' @param p The quantiles at which to evaluate the quantile function
#' @param coefs A vector of length \code{k} representing the basis coefficients
#' @param knots A vector of length \code{k} representing the knot locations
#' @param grid_size The size of the grid that the integral will be evaluated on
#' @return A vector of inverse CDF values. These will always be returned in
#' increasing order, regardless of the original order of the quantiles.
#' @export
qlogspline <- function(p, coefs, knots, grid_size = 1e-2) {
    .Call('_gpcovr_qlogspline', PACKAGE = 'gpcovr', p, coefs, knots, grid_size)
}

#' Generate random draws according to the log spectral density
#'
#' @param n The number of draws
#' @param coefs A vector of length \code{k} representing the basis coefficients
#' @param knots A vector of length \code{k} representing the knot locations
#' @param grid_size The size of the grid that the integral will be evaluated on
#' @return A vector of length \code{n} of random draws from the log spectral density
#' defined by \code{coefs} and \code{knots}
#' @export
rlogspline <- function(n, coefs, knots, grid_size = 1e-2) {
    .Call('_gpcovr_rlogspline', PACKAGE = 'gpcovr', n, coefs, knots, grid_size)
}

#' Bayesian spline fitting, in C++
#'
#' Don't use this directly. Use the wrapper function \code{\link{fitspline}}.
#' @param B B
#' @param y y
#' @param spl spl
#' @param burnin burning
#' @param initBeta initBeta
#' @param initSigma initSigma
#' @param initTau initTau
#' @param initBetaTune initBetaTune
#' @param initSigmaTune initSigmaTune
#' @param initTauTune initTauTune
#' @param s_a s_a
#' @param s_b s_b
#' @param t_a t_a
#' @param t_b t_b
#' @param c0 c0
#' @param c1 c1
#' @param k k
#' @param r r
#' @param oar oar
#' @param progress progress
#' @return A list of length 3. The first element is a matrix where each row is a
#'   random \code{beta} draw. The second and third are vectors where each
#'   element is a random draw of \code{sigma} and \code{tau} respectively.
#' @export
fitsplinecpp <- function(B, y, spl, burnin, initBeta, initSigma, initTau, initBetaTune, initSigmaTune, initTauTune, s_a, s_b, t_a, t_b, c0, c1, k, r, oar, progress) {
    .Call('_gpcovr_fitsplinecpp', PACKAGE = 'gpcovr', B, y, spl, burnin, initBeta, initSigma, initTau, initBetaTune, initSigmaTune, initTauTune, s_a, s_b, t_a, t_b, c0, c1, k, r, oar, progress)
}

