#' Bayesian spline fitting
#'
#' @param B the number of MCMC iterations
#' @param y a vector of observations
#' @param spl a natural cubic spline basis matrix, such as one generated by
#'   \code{\link{nsbasis}}
#' @param burnin the number of iterations to discard as burn-in
#' @param init a named list of initial guesses for \code{beta} (the basis
#'   coefficients), \code{sigma} (the model error estimate), and \code{tau} (the
#'   smoothness penalty).
#' @param tune_init a named list of initial guesses for tuning parameters
#' @param hyperparams a named list of hyperparameters for the priors on
#'   \code{sigma} and \code{tau}. Currently these priors are both hard coded as
#'   inverse gamma.
#' @param c0 adaptive tuning parameter
#' @param c1 adaptive tuning parameter
#' @param k adaptive tuning parameter
#' @param r lag for adaptive tuning
#' @param opt.acc.rate optimal accept rate for adaptive tuning
#' @param progress not currently used
#' @return A list of length 3. The first element is a matrix where each row is a
#'   random \code{beta} draw. The second and third are vectors where each
#'   element is a random draw of \code{sigma} and \code{tau} respectively.
#' @export
fitspline <- function(B, y, spl,
                      burnin = floor(B / 5),
                      init = list(beta = rep(1, ncol(spl)), sigma = 1, tau = 1),
                      tune_init = list(beta = rep(1, ncol(spl)), sigma = 1, tau = 1),
                      hyperparams = list(sigma = c(1, 0.005), tau = c(1, 0.005)),
                      c0 = 10, c1 = 0.8, k = 3, r = 5, opt.acc.rate = 0.41, progress = T)
{
  n <- ncol(spl)

  # storage
  beta_samp <- matrix(NA, nrow = B, ncol = n)
  sigma_samp <- rep(NA, B)
  tau_samp <- rep(NA, B)

  beta_accepts <- matrix(0, nrow = B, ncol = n)
  sigma_accepts <- rep(0, B)
  tau_accepts <- rep(0, B)

  v_beta <- matrix(NA, nrow = B, ncol = n)
  v_sigma <- rep(NA, B)
  v_tau <- rep(NA, B)

  # starting values
  beta <- init$beta
  sigma <- init$sigma
  tau <- init$tau

  beta_samp[1, ] <- beta
  sigma_samp[1] <- sigma
  tau_samp[1] <- tau

  beta_accepts[1, ] <- rep(1, n)
  sigma_accepts[1] <- 1
  tau_accepts[1] <- 1

  v_beta[1, ] <- tune_init$beta
  v_sigma[1] <- tune_init$sigma
  v_tau[1] <- tune_init$tau

  s_a <- hyperparams$sigma[1]
  s_b <- hyperparams$sigma[2]
  t_a <- hyperparams$tau[1]
  t_b <- hyperparams$tau[2]

  f <- fitsplinecpp(B, y, spl, burnin, beta, sigma, tau, v_beta[1, ], v_sigma[1], v_tau[1], s_a, s_b, t_a, t_b, c0, c1, k, r, opt.acc.rate, FALSE)

  return(list(b = f$b,
              s = drop(f$s),
              t = drop(f$t)))
}


#' Matern spectral density function
#'
#' @param x A value
#' @param nu Smoothness parameter
#' @param alpha Inverse range parameter
#' @param sigma Spread parameter
#' @param d The dimension of the Gaussian process
#' @return The Matern density evaluated at \code{x}: \deqn{\frac{\sigma \Gamma
#'   \left(\nu + \frac{d}{2} \right) (4\nu)^{\nu}}{\pi^{d/2}\rho^{2\nu}
#'   \Gamma(\nu)} \left(\frac{4\nu}{\rho^2} + x^2 \right)^{-(\nu + d/2)}}
#' @export
dmatern <- function(x, nu, alpha, sigma, d = 2)
{
  exp(log(sigma) + lgamma(nu + d/2) + nu * log(4 * nu) - d/2 * log(pi) - lgamma(nu) + 2 * nu * log(alpha) - (nu + d/2) * log(4 * alpha * alpha * nu + x * x))
}


#' rmatern
#'
#' Draws random samples from a Matern spectral density.
#' @param n the number of samples to draw
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param df degrees of freedom of the envelope t density. This can be tuned to get a better acceptance rate
#' @return a vector of random draws from the Matern spectral density
#' @export
#' @export
rmatern <- function(n, nu, alpha, sigma, df)
{
  samps <- NULL
  while(length(samps) < n)
  {
    t <- stats::rt(5*n, df = df)
    scale <- find_max_ratio(nu, alpha, sigma, df)
    ratio <- dmatern(t, nu, alpha, sigma) / (1.01 * scale * stats::dt(t, df = df))
    accept <- stats::runif(5*n) < ratio
    samps <- c(samps, t[accept])
  }
  samps <- samps[1:n]
  return(samps)
}


#' Ratio of Matern density to t density
#'
#' @param x a value
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param df degrees of freedom of the t density
#' @return The ratio of the Matern density to the t density, evaluated at \code{x}
#' @export
rat_matern_t <- function(x, nu, alpha, sigma, df)
{
  dmatern(x, nu, alpha, sigma) / stats::dt(x, df)
}


#' Find max ratio
#'
#' Find the maximum of \code{rat_matern_t}, the ratio of the Matern density to the t density.
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param df degrees of freedom of the t distribution
#' @return the maximum value of f(x), where f is the ratio of the Matern to the t
#' @seealso \code{\link{rat_matern_t}}
#' @export
find_max_ratio <- function(nu, alpha, sigma, df)
{
  xmax <- 1000 * alpha
  stats::optimize(rat_matern_t, interval = c(0, xmax), maximum = T, nu = nu, alpha = alpha, sigma = sigma, df = df)$objective
}



#' Matern covariance function
#'
#' The true Matern covariance function.
#' @param h distance value/vector/matrix
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @return The covariance associated with the distance h
#' @export
matern_cor <- function(h, nu, alpha, sigma) {
  out <- rep(sigma, length(h))
  idx_non0 <- which(h != 0)
  tmp <- 2 * sqrt(nu) * h[idx_non0] * alpha
  out[idx_non0] <- sigma * tmp^nu * besselK(tmp, nu) / (2^(nu-1) * gamma(nu))
  if(is.matrix(h)) dim(out) <- dim(h)
  out
}




#' Generate a Gaussian process
#'
#' Generates a Gaussian random field on the unit square. Observation locations
#' are guaranteed to be a certain minimum distance apart.
#' @param n the number of observations to generate
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param tau nugget effect
#' @param mindist the minimum distance between two observation locations
#' @return a list with two elements. The first is a data frame with the x and y
#'   coordinates of the observation locations and z, which is the value of the
#'   observation. The second is a matrix of distances between the observations.
#'   We return this so that it doesn't need to be calculated separately later
#'   on.
#' @export
generateGP <- function(n, nu, alpha, sigma, tau, mindist = 0.005) {
  # grid coordinates from 0.005 to 0.995 in increments of 0.015
  x <- seq(mindist, 1 - mindist, by = 3 * mindist)
  if(n > length(x)^2)
  {
    stop(paste0('when mindist = ', mindist, ', sample size cannot exceed ', length(x)^2, '.'))
  }
  # create grid with small perturbation at each point
  grid_all <- expand.grid(x = x, y = x) + stats::runif(2*length(x)^2, -mindist, mindist)
  # randomly sample n points within this grid
  grid <- grid_all[sample(1:nrow(grid_all), size = n), ]
  # calculate distances between every pair of points
  distances <- as.matrix(stats::dist(grid))
  # calculate Matern covariance function at each of those distances
  covmat <- matern_cor(distances, nu, alpha, sigma)
  # diagonal of sigma is 0, change it to 1 + tau2
  diag(covmat) <- sigma + tau
  ## generate rv's with covariance matrix = sigma
  R <- chol(covmat)
  u <- stats::rnorm(nrow(grid))
  z <- crossprod(R, u)

  return(list(dat = data.frame(grid, z = z),
              dist = distances))
}


#' Approximated normal log likelihood, Matern covariance
#'
#' @param x vector of observations
#' @param h distance matrix between the observations
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param tau nugget effect
#' @param num_samps the number of MC samples to use. Ignored if \code{mc} is not null.
#' @param mc_samps vector of MC samples. If \code{NULL}, generate them with calls to \code{\link{rmatern}} and \code{cudatest::mc}.
#' @return the log likelihood.
#' @export
normal_ll <- function(x, h, nu, alpha, sigma, tau, num_samps, mc_samps = NULL)
{
  n <- length(x)
  covmat <- diag(1+tau, nrow = n, ncol = n)
  if(is.null(mc_samps))
  {
    samps <- rmatern(num_samps, nu, alpha, sigma, 0.1)
    mc_samps <- cudatest::mc(h[lower.tri(h)], samps)
  }
  covmat[lower.tri(covmat)] <- mc_samps
  covmat[upper.tri(covmat)] <- t(covmat)[upper.tri(covmat)]

  cholmat <- chol(covmat)
  log_det <- sum(log(diag(cholmat)))
  quadform <- drop(crossprod(backsolve(cholmat, x, transpose = TRUE)))
  ll <- -0.5 * (n * log(2*pi) + 2 * log_det + quadform)

  ll
}



#' Exact normal log likelihood
#'
#' @param x vector of observations
#' @param h distance matrix between the observations
#' @param nu smoothness parameter
#' @param alpha inverse range parameter
#' @param sigma scale parameter
#' @param tau nugget effect
#' @return the log likelihood.
#' @export
normal_ll_exact <- function(x, h, nu, alpha, sigma, tau)
{
  covmat <- matern_cor(h, nu, alpha, sigma)
  diag(covmat) <- sigma + tau
  cholmat <- chol(covmat)
  log_det <- sum(log(diag(cholmat)))
  quadform <- drop(crossprod(backsolve(cholmat, x, transpose = TRUE)))
  -0.5 * (length(x) * log(2*pi) + 2 * log_det + quadform)
}


#' Calculate the error bounds for the log-log spectral density
#'
#' @param b A matrix in which each row is a vector of spline basis coefficients
#' from the MCMC
#' @param x A vector of x values to evaluate the error bounds over
#' @param knots The knots used in the MCMC
#' @return The 2.5% and 97.5% percentiles at each x value
#' @export
get_error_bounds <- function(b, x, knots)
{
  curves <- apply(b, 1, function(beta) dloglogspline(x, beta, knots))
  quantiles <- t(apply(curves, 1, function(x) stats::quantile(x, c(0.025, 0.975))))
  quantiles
}

#' Calculate the error bounds for the covariance function
#'
#' WARNING: this uses the GPU Monte Carlo integration and will crash your
#' computer if you do more than 1000 - 5000 coefficient vectors at a time.
#' This is because R is stupid and doesn't free up memory when it needs to.
#'
#' TODO: make this take every 100th or so row from b and estimate the
#' bounds that way.
#'
#' @param b A matrix in which each row is a vector of spline basis coefficients
#' from the MCMC
#' @param x A vector of x values to evaluate the error bounds over
#' @param knots The knots used in the MCMC
#' @return The 2.5% and 97.5% percentiles at each x value
#' @export
get_cov_error_bounds <- function(b, x, knots)
{
  curves <- apply(b, 1, function(beta) cudatest::mc(x, exp(rlogspline(50000, beta, knots))))
  quantiles <- t(apply(curves, 1, function(x) stats::quantile(x, c(0.025, 0.975))))
  quantiles
}
